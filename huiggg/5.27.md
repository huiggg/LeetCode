## 20 有效的括号

```
public boolean isValid(String s) {
​    LinkedList<Character> stack = new LinkedList<>();
​    char[] str = s.toCharArray();

​    for(int i=0;i<str.length;i++){
​      char ch = str[i];
​      if(ch == '(' || ch == '[' || ch == '{')
​        stack.push(ch);
​      else{
​        if(stack.isEmpty())
​          return false;

​        if((ch == ')' && stack.getFirst()=='(') || (ch == '}' && stack.getFirst()=='{') || (ch == ']' && stack.getFirst()=='['))
​          stack.pop();
​        else  
​          return false;
​      }
​    }
​    if(stack.isEmpty())
​      return true;
​    else
​      return false;
  }
```

## 22 括号生成

```
class Solution {
  List<String> res = new LinkedList<>();
  public List<String> generateParenthesis(int n) {
​    if(n==0)
​      return res;
​    findPar(n,n,"");
​    return res;
  }

  private void findPar(int left,int right,String cur){
​    if(left == 0 && right == 0){
​      res.add(cur);
​      return;
​    }
​    if(left > 0)
​      findPar(left-1,right,cur+"(");
​     
​    if(right > left)
​      findPar(left,right-1,cur+")");
  }
}
```

## 1096 花括号展开II

```
public List<String> braceExpansionII(String expression) {
​    Queue<String> queue = new LinkedList<>();
​    queue.add(expression);

​    Set<String> res = new HashSet<>();
​    StringBuilder sb = new StringBuilder();

​    while (!queue.isEmpty()) {
​      // 拿到需要处理的表达式
​      String exp = queue.poll();

​      // 如果表达式中没有 {，则将这个表达式加入结果中
​      if (exp.indexOf("{") == -1) {
​        res.add(exp);
​        continue;
​      }

​      // 找到表达式中第一对 {}
​      int i = 0;
​      int left = 0;
​      int right = 0;
​      while (exp.charAt(i) != '}') {
​        if (exp.charAt(i) == '{') left = i;
​        i++;
​      }
​      right = i;
​      
​      String before = exp.substring(0, left); // 拿到第一对括号中的前面部分 (不包括 {)
​      String after = exp.substring(right + 1); // 拿到第一对括号中的后面部分 (不包括 })
​      String[] strs = exp.substring(left + 1, right).split(","); // 按照 , 分割第一对括号中的元素 (不包括 {})

​      // 将 before 、 strs 中的每个元素以及 after 拼接成字符串放入到队列中，方便后面处理
​      for (String str : strs) {
​        sb.setLength(0);
​        queue.add(sb.append(before).append(str).append(after).toString());
​      }
​    }

​    // 结果处理
​    List<String> ans = new ArrayList<>(res);
​    Collections.sort(ans);
​    return ans;
  }
```

