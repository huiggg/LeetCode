## 392 判断子序列

```
public boolean isSubsequence(String s, String t) {
​    if(s.length() == 0)
​      return true;
​    if(s.length() != 0 &&t.length() == 0)
​      return false;
​    int i=0,j=0;
​    while(i<s.length() && j<t.length()){
​      if(s.charAt(i) == t.charAt(j)){
​        i++;
​        j++;
​      }
​      else
​        j++;
​    }
​    return i==s.length();
  }
```

## 1139  最大的以 1 为边界的正方形 

```
public int largest1BorderedSquare(int[][] grid) {
​    int row = grid.length;
​    int col = grid[0].length;

​    int[][] top = new int[row][col];
​    int[][] left = new int[row][col];

​    for(int i=0;i<row;i++){
​      for(int j =0;j<col;j++){
​        if(grid[i][j] != 0){
​          top[i][j] = i>0? top[i-1][j] + 1:1;
​          left[i][j] = j>0? left[i][j-1]+1:1;
​        }
​      }
​    }
​    for(int a= Math.min(row,col);a>0;a--){
​      for(int i=row-1;i-a+1>=0;i--){
​        for(int j = col-1;j-a+1>=0;j--){
​          if(top[i][j] >=a && left[i][j]>=a && left[i-a+1][j]>=a && top[i][j-a+1]>=a)
​            return a*a;
​        }
​      }
​    }
​    return 0;
  }
```

## 546 移除盒子

```
class Solution {
  int[][][] dp = new int[100][100][100];
  public int removeBoxes(int[] boxes) {
​    int n = boxes.length;
​    return helper(boxes,0,n-1,0);
  }
  public int helper(int[] boxes,int i,int j,int k){
​    if(j<i) return 0;
​    if(dp[i][j][k] > 0)
​      return dp[i][j][k];

​    int res = (1+k)*(1+k) + helper(boxes,i+1,j,0);
​    for(int m=i+1; m<=j;++m){
​      if(boxes[i] == boxes[m]){
​        res = Math.max(res,helper(boxes,i+1,m-1,0)+helper(boxes,m,j,k+1));
​      }
​    }
​    dp[i][j][k] = res;
​    return res;
  }
}
```

