## 463 岛屿的周长

```
public int islandPerimeter(int[][] grid) {
​    for(int i=0;i<grid.length;i++){
​      for(int j =0; j < grid[0].length;j++){
​        if(grid[i][j] == 1)
​          return dfs(grid,i,j);
​      }
​    }
​    return 0;
  }

  int dfs(int[][] grid,int i,int j){
​    if(!(i>=0 && i < grid.length && j >=0 && j < grid[0].length)){
​      return 1;
​    }

​    if(grid[i][j] == 0)
​      return 1;
​    if(grid[i][j] != 1)
​      return 0;
​    grid[i][j] = 2;
​    return dfs(grid,i-1,j) + dfs(grid,i+1,j) + dfs(grid,i,j-1)+dfs(grid,i,j+1);
  }
```

## 701 二叉搜索树中的插入操作

```
public TreeNode insertIntoBST(TreeNode root, int val) {
​    if(root == null)
​      return new TreeNode(val);
​   
​    if(root.val < val)
​      root.right = insertIntoBST(root.right,val);
​    else
​      root.left = insertIntoBST(root.left,val);
​
​    return root;
  }
```

## 1335 工作计划的最低难度

```
public int minDifficulty(int[] jobDifficulty, int d) {
​    int length = jobDifficulty.length;
​    if (length < d)
​      return -1;

​    //dp[i][j] 表示前 i 天 完成 前 j 项工作的花费的最小难度 i >= j
​    int[][] dp = new int[d][length];
​    int jobD = 0;
​    for (int i = 0; i < jobDifficulty.length; i++) {
​      jobD = Math.max(jobD, jobDifficulty[i]);
​      dp[0][i] = jobD;
​    }

​    for(int k = 1;k < d;k++){
​      for(int num = k;num < jobDifficulty.length;num++){
​        //dp[k][num]
​        dp[k][num] = Integer.MAX_VALUE;
​        int temp = 0;
​        for(int n = num;n >= k;n--){
​          temp = Math.max(temp, jobDifficulty[n]);
​          dp[k][num] = Math.min(dp[k-1][n-1] + temp, dp[k][num]);
​        }
​      }
​    }
​    return dp[d-1][jobDifficulty.length-1];
  }
```

