## 面试题13

```java
class Solution {

  //统计到达的数量
  int counts=0;
  
  public int movingCount(int m, int n, int k) {
​    //辅助数组 用来标记是否统计过
​    int[][] visited = new int[m][n];

​    //从 0,0位置开始统计
​    helper(visited,0,0,m-1,n-1,k);
​    return counts;
  }

  //传入i,j两点 判断当前点是否符合规则 符合规则下继续对下右两个方向递归判断
  private void helper(int[][] visited,int i,int j,int m,int n,int k){
​    if(i<=m && j<=n && visited[i][j]!=1 && (indexSum(i)+indexSum(j))<=k){
​      counts++;
​      visited[i][j]=1;
​      helper(visited,i+1,j,m,n,k);
​      helper(visited,i,j+1,m,n,k);
​    }
  }

  //根据传入的数 求出各位上的数字累加和
  private int indexSum(int index){
​    int sum = index%10;
​    int tmp = index/10;
​    while(tmp>0){
​      sum+=tmp%10;
​      tmp/=10;
​    }
​    return sum;
  }
}
```

## 466 统计重复个数

```java
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        if(n1==0) 
            return 0;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int l1 = s1.length();
        int l2 = s2.length();
        int couts1=0;//经历多少s1
        int couts2=0;//经历多少s2
        int p=0;//当前在s2的位置
        Map<Integer,int[]> mp = new HashMap<>();//记录每一次s1扫描结束后当前的状态，寻找循环
        while(couts1<n1){
            for(int i=0;i<l1;i++){
                if(c1[i]==c2[p]){//往前
                    p++;
                    if(p==l2){//s2扫描结束从头开始循环
                        p=0;
                        couts2++;
                    }
                }
            }
            couts1++;
            if(!mp.containsKey(p)){
                mp.put(p,new int[]{couts1,couts2});//记录当前状态   
    ​        }
    ​        else{//出现了循环 这次结束后p的位置和以前某一次一样，就是循环
    ​            int[] last =mp.get(p);
    ​            int circle1= couts1-last[0];
    ​            int circle2= couts2-last[1];
    ​            couts2 += circle2*((n1-couts1)/circle1);
    ​            couts1 = couts1+((n1-couts1)/circle1)*circle1;//更新新他们
    ​        }
    ​    }
    ​    return couts2/n2;
	}
}
```

